
# Copyright (C) 2005, 2006 Nikolas Zimmermann <zimmermann@kde.org>
# Copyright (C) 2006 Anders Carlsson <andersca@mac.com> 
# Copyright (C) 2006, 2007 Samuel Weinig <sam@webkit.org>
# Copyright (C) 2006 Alexey Proskuryakov <ap@webkit.org>
# Copyright (C) 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
# Copyright (C) 2009 Cameron McCormack <cam@mcc.id.au>
# Copyright (C) Research In Motion Limited 2010. All rights reserved.
# Copyright (C) 2012 Tim Mahoney <tim.mahoney@me.com>
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Library General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Library General Public License for more details.
# 
# You should have received a copy of the GNU Library General Public License
# aint with this library; see the file COPYING.LIB.  If not, write to
# the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
# Boston, MA 02110-1301, USA.
#

package CodeGeneratorRB;

use constant FileNamePrefix => "RB";
my $prefix = FileNamePrefix;

use constant GenerateCustomImplementation => 0;

# Global Variables
my $module = "";
my $outputDir = "";

my $interfaceName = "";
my $className = "";
my $interface;
my $implSelf = "selfImpl";
my $implSelfDeclaration;
my $implSelfConverter;
my $svgSelf = "";

my @headerContentHeader = ();
my @headerContent = ();

my @implContentHeader = ();
my @implContent = ();
my %implIncludes = ();
my @implCustomContent = ();

# Constants
my $exceptionInit = "ExceptionCode ec = 0;";
my $exceptionRaiseOnError = "RB::setDOMException(ec);";
my $notImplementedFixme = "// FIXME: Implement this custom function.";
my $notImplementedRaise = "rb_raise(rb_eNotImpError, \"This function is not currently implemented for Ruby in WebKit. Sorry!\");";

# Default License Templates
my $headerLicenseTemplate = << "EOF";
/*
 * Copyright (C) Research In Motion Limited 2010. All rights reserved.
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
 * Copyright (C) 2006 Samuel Weinig <sam.weinig\@gmail.com>
 * Copyright (C) Research In Motion Limited 2010. All rights reserved.
 * Copyright (C) 2012 Tim Mahoney <tim.mahoney\@me.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public License
 * along with this library; see the file COPYING.LIB.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301, USA.
 */
EOF

my $implementationLicenseTemplate = << "EOF";
/*
 * This file is part of the WebKit open source project.
 * This file has been generated by generate-bindings.pl. DO NOT MODIFY!
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public License
 * along with this library; see the file COPYING.LIB.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301, USA.
 */
EOF

# Default constructor
sub new
{
    my $object = shift;
    my $reference = { };

    $codeGenerator = shift;
    shift; # $useLayerOnTop
    shift; # $preprocessor
    $writeDependencies = shift;

    bless($reference, $object);
    return $reference;
}

# Returns true if we should just skip this interface.
sub SkipInterface
{
    my $object = shift;
    my $dataNode = shift;
    
    # We made a custom event listener.
    return 1 if $dataNode->name eq "EventListener";
    return 1 if $dataNode->name eq "ElementTimeControl";
    
    return 0;
}

sub GetClassName
{
    my $name = shift;

    # special cases
    return "RBObject" if $name eq "DOMObject";
    return "bool" if $name eq "boolean";
    return $name if $codeGenerator->IsPrimitiveType($name);

    return "${prefix}${name}";
}

# Params: 'domClass' struct
sub GenerateInterface
{
    my $object = shift;
    my $dataNode = shift;
    my $defines = shift;

    $interfaceName = $dataNode->name;
    $className = GetClassName($interfaceName);
    $interface = $dataNode;

    # Convert the "self" argument to the native WebKit version.
    # SVG has some differences.
    $implSelfConverter = RBToNativeConverter("self", $interfaceName, 0, 1);
    my $implSelfType = GetNativeType($interfaceName);
    if ($codeGenerator->IsSVGTypeNeedingTearOff($interfaceName)) {
        my $svgType = $codeGenerator->GetSVGTypeNeedingTearOff($interfaceName);
        if ($interfaceName =~ /List$/) {
            $svgSelf = $implSelf;
            $implSelfDeclaration = "$implSelfType $implSelf = impl<$svgType >(self)";
        } else {
            $svgSelf = "selfImplTearOff";
            my $svgWrappedType = $codeGenerator->GetSVGWrappedTypeNeedingTearOff($interfaceName);
            $implSelfDeclaration = "$implSelfType $svgSelf = impl<$svgType >(self);\n";
            $implSelfDeclaration .= "    $svgWrappedType* $implSelf = &$svgSelf->propertyReference()";
        }
    } else {
        $implSelfDeclaration = "$implSelfType $implSelf = $implSelfConverter";
    }
    
    $codeGenerator->LinkOverloadedFunctions($dataNode);

    # Start actual generation.
    if ($dataNode->extendedAttributes->{"Callback"}) {
        $object->GenerateCallbackHeader($dataNode);
        $object->GenerateCallbackImplementation($dataNode);
    } else {
        $object->GenerateHeader($dataNode);
        $object->GenerateImplementation($dataNode);
    }
}

my %nativeType = (
    "CompareHow" => "Range::CompareHow",
    "DOMString" => "const String&",
    # FIXME: Add proper support for T[], T[]?, sequence<T>
    "DOMString[]" => "RefPtr<DOMStringList>",
    "DOMObject" => "ScriptValue",
    "NodeFilter" => "RefPtr<NodeFilter>",
    "SerializedScriptValue" => "RefPtr<SerializedScriptValue>",
    "IDBKey" => "PassRefPtr<IDBKey>",
    "Dictionary" => "Dictionary",
    "any" => "ScriptValue",
    "boolean" => "bool",
    "double" => "double",
    "float" => "float",
    "short" => "short",
    "long" => "int",
    "unsigned long" => "unsigned",
    "unsigned short" => "unsigned short",
    "long long" => "long long",
    "unsigned long long" => "unsigned long long",
    "MediaQueryListListener" => "RefPtr<MediaQueryListListener>",
    "DOMTimeStamp" => "DOMTimeStamp",    
);

sub GetNativeVectorInnerType
{
    my $arrayOrSequenceType = shift;

    return "String" if $arrayOrSequenceType eq "DOMString";
    return $nativeType{$arrayOrSequenceType} if exists $nativeType{$arrayOrSequenceType};
    return "RefPtr<${arrayOrSequenceType}> ";
}

sub GetNativeType
{
    my $type = shift;

    return "RefPtr<$type>" if $type =~ /Callback/ or $type =~ /Listener/ ;

    my $svgNativeType = $codeGenerator->GetSVGTypeNeedingTearOff($type);
    return "${svgNativeType}*" if $svgNativeType;
    return "RefPtr<DOMStringList>" if $type eq "DOMStringList" or $type eq "DOMString[]";
    return $nativeType{$type} if exists $nativeType{$type};

    my $sequenceType = $codeGenerator->GetSequenceType($type);
    return "Vector<" . GetNativeVectorInnerType($sequenceType) . ">" if $sequenceType;

    return "String" if $codeGenerator->IsEnumType($type);

    return "${type}*";
}

# Params: 'idlDocument' struct
sub GenerateModule
{
    my $object = shift;
    my $dataNode = shift;

    $module = $dataNode->module;
}

sub GetParent
{
    my $dataNode = shift;
    my $numParents = @{$dataNode->parents};

    my $parent = "";
    if ($numParents eq 0) {
        $parent = "${prefix}Object";
        $parent = "${prefix}EventTarget" if $dataNode->extendedAttributes->{"EventTarget"} and $interfaceName ne "EventTarget";
    } elsif ($numParents eq 1) {
        my $parentName = $dataNode->parents(0);
        $parent = $prefix . $parentName;
    } else {
        my @parents = @{$dataNode->parents};
        my $firstParent = shift(@parents);
        $parent = ${prefix} . $firstParent;
    }

    return $parent;
}

# Returns true if this function needs custom implementation.
# This means that we shouldn't write the implementation here.
sub NeedsCustomImplementation
{
    my $data = shift;
    
    return 1 if $data->signature->extendedAttributes->{"Custom"}
        or $data->signature->extendedAttributes->{"CustomGetter"}
        or $data->signature->extendedAttributes->{"CustomSetter"};
}

# Generates a custom implementation stub for a function.
sub GenerateCustomFunctionStub
{
    my $data = shift;
    
    return 1 if $data->signature->extendedAttributes->{"Custom"}
        or $data->signature->extendedAttributes->{"CustomGetter"}
        or $data->signature->extendedAttributes->{"CustomSetter"};
}

sub SkipFunction
{
    # FIXME: Remove this function.
    my $function = shift;
    return 0;
}

sub SkipAttribute
{
    my $attribute = shift;

    # Ruby doesn't implement constructor attributes.
    return 1 if $attribute->signature->type =~ /Constructor$/;
    
    $codeGenerator->AssertNotSequenceType($attribute->signature->type);

    return 0;
}

sub GetCallbackCPPType
{
    my $type = shift;

    return "unsigned" if $type eq "unsigned long";
    return "unsigned short" if $type eq "CompareHow";
    return "double" if $type eq "Date";
    return "bool" if $type eq "boolean";
    return "const String&" if $type eq "DOMString";
    return $type if $codeGenerator->IsPrimitiveType($type);
    return "${type}*";
}

sub ConversionNeeded
{
    my $type = shift;
    return !$codeGenerator->IsNonPointerType($type) && !$codeGenerator->IsStringType($type);
}

my %rubyToPrimitive = (
    "int" => "NUM2INT",
    "short" => "NUM2INT",
    "long" => "NUM2LONG",
    "long long" => "NUM2LL",
    "unsigned int" => "NUM2UINT",
    "unsigned short" => "NUM2UINT",
    "unsigned long" => "NUM2ULONG",
    "unsigned long long" => "NUM2ULL",
    "float" => "NUM2DBL",
    "double" => "NUM2DBL",
    "boolean" => "RTEST"
);

sub GetPrimitiveTypeConverter
{
    my $argName = shift;
    my $type = shift;
    
    my $converter = $rubyToPrimitive{$type};
    return "$converter($argName)";
}

sub RBToNativeConverter
{
    my $argName = shift;
    my $type = shift;
    my $extendedAttributes = shift;
    my $forcePointer = shift;
    $extendedAttributes = () if !$extendedAttributes;

    # FIXME: Change the one-line returns to standard if statements for clarity.

    if ($codeGenerator->IsEnumType($type)) {
        return "rbToString($argName)";
    }

    return "rbToDate($argName)" if $type eq "Date";

    # Check if this signature is Optional.
    my $option = $extendedAttributes->{"Optional"};
    return "rbStringOrNullString($argName)" if $option and $option eq "DefaultIsNullString";
    return "rbStringOrUndefined($argName)" if $option and $option eq "DefaultIsUndefined" and $codeGenerator->IsStringType($type);
    return "NIL_P($argName) ? 0 : " . GetPrimitiveTypeConverter($argName, $type) if $option and $option eq "DefaultIsUndefined" and $codeGenerator->IsPrimitiveType($type);

    if ($type eq "DOMString") {
        # FIXME: This implements [TreatNullAs=NullString] and [TreatUndefinedAs=NullString],
        # but the Web IDL spec requires [TreatNullAs=EmptyString] and [TreatUndefinedAs=EmptyString].
        if (($extendedAttributes->{"TreatNullAs"} and $extendedAttributes->{"TreatNullAs"} eq "NullString") and ($extendedAttributes->{"TreatUndefinedAs"} and $extendedAttributes->{"TreatUndefinedAs"} eq "NullString")) {
            return "rbStringOrNullString(${argName})";
        }
        if (($extendedAttributes->{"TreatNullAs"} and $extendedAttributes->{"TreatNullAs"} eq "NullString") or $extendedAttributes->{"Reflect"}) {
            return "rbStringOrNullString($argName)";
        }

        return "StringValueCStr($argName)";
    }

    if ($extendedAttributes->{"Callback"}) {
        $implIncludes{"DOMWindow.h"} = 1;
        $implIncludes{"RBDOMBinding.h"} = 1;
        return "RB${type}::create($argName, RBDOMBinding::currentWindow()->scriptExecutionContext())";
    }
    

    # FIXME: Something needs to be done about the 'track' variable of TrackEvent's TrackEventInit.
    return "rbToTrack($argName)" if $type eq "object" and $argName eq "track";

    if ($type eq "Dictionary") {
        $implIncludes{"Dictionary.h"} = 1;
        return "Dictionary($argName)";
    }
    
    return "StringValueCStr($argName)" if $codeGenerator->IsStringType($type);
    
    if ($codeGenerator->IsPrimitiveType($type)) {
        return "clampTo<$type>(NUM2DBL($argName))" if $extendedAttributes->{"Clamp"};
        return GetPrimitiveTypeConverter($argName, $type);
    }

    if ($type eq "MediaQueryListListener") {
        $implIncludes{"RBScriptValue.h"} = 1;
        return "MediaQueryListListener::create(RBScriptValue::scriptValue($argName))";
    }

    my $arrayType = $codeGenerator->GetArrayType($type);
    if ($arrayType) {
        return "rbToNativeArray<" . GetNativeVectorInnerType($arrayType) . ">($argName)";
    }
    my $sequenceType = $codeGenerator->GetSequenceType($type);
    if ($sequenceType) {
        return "rbToNativeArray<" . GetNativeVectorInnerType($sequenceType) . ">($argName)";
    }

    if ($type eq "Array" and $argName eq "ports") {
        return "rbToNativeArray<RefPtr<MessagePort> >($argName)";
    }

    my $svgType = $codeGenerator->GetSVGTypeNeedingTearOff($type);
    if ($svgType) {
        my $svgReturn = "impl<$svgType >($argName)";
        if (!($interfaceName =~ /List$/)) {
            $svgReturn = "$svgReturn->propertyReference()";
            if ($forcePointer and $codeGenerator->GetSVGWrappedTypeNeedingTearOff($interfaceName) ne "float") {
                $svgReturn = "(&$svgReturn)";
            }
        }
        return $svgReturn;
    }
    
    return "static_cast<Range::CompareHow>(NUM2INT($argName))" if $type eq "CompareHow";
    return "RBEventListener::create($argName)" if $type eq "EventListener";
    return "SerializedScriptValue::create($argName)" if $type eq "SerializedScriptValue";
    return "impl<DOMStringList>($argName)" if $type eq "DOMString[]";
    return "RBScriptValue::scriptValue($argName)" if $type eq "any";
    return "impl<${type}>($argName)" if $type ne "DOMObject";
    return "RBScriptValue::scriptValue($argName)";
}

sub RBToNative
{
    my $argName = shift;
    my $signature = shift;
    my $forcePointer = shift;
    my $type = $signature->type;
    my $extendedAttributes = $signature->extendedAttributes;
    return RBToNativeConverter($argName, $type, $extendedAttributes, $forcePointer);
}

sub AddIncludesForType
{
    my $type = shift;

    if ($type eq "SVGNumber" or $type eq "SVGPoint") {
        $implIncludes{"${prefix}${type}.h"} = 1;
        return;
    }

    return if $codeGenerator->IsEnumType($type);
    return if $codeGenerator->SkipIncludeHeader($type);

    my $arrayType = $codeGenerator->GetArrayType($type);
    $arrayType = $codeGenerator->GetSequenceType($type) if !$arrayType;
    $arrayType = "DOMStringList" if $arrayType eq "DOMString";
    if ($arrayType) {
        if (!$codeGenerator->SkipIncludeHeader($arrayType)) {
            $implIncludes{"${prefix}${arrayType}.h"} = 1;
            $implIncludes{"$arrayType.h"} = 1;
        }
        return;
    }

    return if $codeGenerator->IsNonPointerType($type);
    return if $type eq "AbstractView";
    return if $type =~ /Constructor/;
    return if $type eq "object";
    return if $type eq "Array";
    
    if ($type eq "Dictionary") {
        $implIncludes{"Dictionary.h"} = 1;
        return;
    }

    if ($codeGenerator->IsStringType($type)) {
        $implIncludes{"<wtf/text/AtomicString.h>"} = 1;
        $implIncludes{"<wtf/text/CString.h>"} = 1;
        $implIncludes{"KURL.h"} = 1;
        return;
    }

    if ($type eq "DOMObject") {
        $implIncludes{"${prefix}Object.h"} = 1;
        $implIncludes{"RBScriptValue.h"} = 1;
        return;
    }

    if ($type eq "SerializedScriptValue") {
        $implIncludes{"SerializedScriptValue.h"} = 1;
        return;
    }

    if ($type eq "MediaQueryListListener") {
        $implIncludes{"MediaQueryListListener.h"} = 1;
        return;
    }

    if ($type =~ /SVGPathSeg/) {
        my $realName = $type;
        $realName =~ s/Abs|Rel//;
        $implIncludes{"$realName.h"} = 1;
        $implIncludes{"${prefix}${type}.h"} = 1;
        return;
    }

    $implIncludes{"Node.h"} = 1 if $type eq "NodeList";
    $implIncludes{"StylePropertySet.h"} = 1 if $type eq "CSSStyleDeclaration";

    if ($type eq "any") {
        $implIncludes{"RBScriptValue.h"} = 1;
        return;
    }

    # Default, include the same named file (the implementation) and the same name prefixed with FileNamePrefix. 
    if ($codeGenerator->IsTypedArrayType($type)) {
        $implIncludes{"<wtf/$type.h>"} = 1;
    } elsif ($type ne "DOMObject") {
        $implIncludes{"$type.h"} = 1;
    }
    $implIncludes{"${prefix}${type}.h"} = 1;
}

# Decamelizes a string. "CamelCase" becomes "camel_case".
sub Decamelize
{
    my $s = shift;
    $s =~ s{([^a-zA-Z]?)([A-Z]*)([A-Z])([a-z]?)}{
        my $fc = pos($s)==0;
        my ($p0,$p1,$p2,$p3) = ($1,lc$2,lc$3,$4);
        my $t = $p0 || $fc ? $p0 : '_';
        $t .= $p3 ? $p1 ? "${p1}_$p2$p3" : "$p2$p3" : "$p1$p2";
        $t;
    }ge;
    return $s;
}

sub GetRubyClassVariableName
{
    my $interfaceName = shift;
    return "rb_cObject" if $interfaceName eq "Object";
    return "rb_cDOM$interfaceName";
}

# Returns the name of a function in Ruby for the name of a function in the interface.
# For example:
#   $functionName = 'getElementById';
#   $rbFunctionName = GetRubyFunctionName($functionName);
#   # $rbFunctionName == 'get_element_by_id'.
sub GetRubyFunctionName
{
    my $name = shift;    
    
    # If this is all uppercase, then keep it all uppercase.
    # Weird, but we need this for the 'URL' attribute in EventSource.
    return $name if uc($name) eq $name;
    return Decamelize($name);
}

sub GetStaticFunctionName
{
    my $name = shift;
    $name = "dom" . ucfirst($name) if $name eq "assert";

    return GetRubyFunctionName($name);
}

# Returns a name for the Ruby class that should correspond to the indicated interface name.
# This is needed to make sure we don't try to overwrite certain class names.
# For example, the "File" class already exists in Ruby,
sub GetRubyClassName
{
    my $dataNode = shift;

    my $idlInterfaceName = $dataNode->extendedAttributes->{"InterfaceName"};
    return $idlInterfaceName if $idlInterfaceName;

    return $dataNode->name;
}

sub CountOptionalArguments
{
    $function = shift;

    my $optionalCount = 0;
    foreach my $parameter (@{$function->parameters}) {
        $optionalCount++ if $parameter->extendedAttributes->{"Optional"}
    }

    # If at least one callback is mandatory, then make it optional in case it's the implicit block.
    $optionalCount++ if ContainsCallbackParameters($function);

    return $optionalCount;
}

sub IsCallback
{
    my $param = shift;
    return 1 if $param->extendedAttributes->{"Callback"};
    return 1 if $param->type eq "TimeoutHandler";
    return 1 if $param->type eq "EventListener";
    return 1 if $param->type =~ /Callback/;
}

sub ContainsCallbackParameters
{
    my $function = shift;

    foreach my $param (@{$function->parameters}) {
        return 1 if IsCallback($param);
    }

    return 0;
}

sub GenerateCallWith
{
    my $callWith = shift;
    return () unless $callWith;
    my $outputArray = shift;
    my $function = shift;

    my @callWithArgs;
    $implIncludes{"RBScriptState.h"} = 1;
    push(@$outputArray, "    RBScriptState* state = RBScriptState::current();\n");

    if ($codeGenerator->ExtendedAttributeContains($callWith, "ScriptState")) {
        push(@callWithArgs, "state");
    }

    if ($codeGenerator->ExtendedAttributeContains($callWith, "ScriptExecutionContext")) {
        push(@$outputArray, "    ScriptExecutionContext* scriptContext = state->domWindow()->scriptExecutionContext();\n");
        push(@$outputArray, "    if (!scriptContext)\n");
        push(@$outputArray, "        return Qnil;\n\n");
        $implIncludes{"DOMWindow.h"} = 1;
        push(@callWithArgs, "scriptContext");
    }

    if ($function and $codeGenerator->ExtendedAttributeContains($callWith, "ScriptArguments")) {
        push(@$outputArray, "    RefPtr<ScriptArguments> scriptArguments(RBScriptCallStackFactory::createScriptArguments(state, argc, argv, " . @{$function->parameters} . "));\n");
        $implIncludes{"ScriptArguments.h"} = 1;
        $implIncludes{"RBScriptCallStackFactory.h"} = 1;
        push(@callWithArgs, "scriptArguments.release()");
    }

    return @callWithArgs;
}

sub GenerateCallbackHeader
{
    my $object = shift;
    my $dataNode = shift;

    # - Add default header template
    @headerContentHeader = split("\r", $headerLicenseTemplate);
    push(@headerContentHeader, "\n#ifndef $className" . "_h");
    push(@headerContentHeader, "\n#define $className" . "_h\n\n");

    my $conditionalString = $codeGenerator->GenerateConditionalString($dataNode); 
    push(@headerContentHeader, "#if ${conditionalString}\n\n") if $conditionalString;

    # - INCLUDES -
    $headerIncludes{"RBCallback.h"} = 1;
    $headerIncludes{"$interfaceName.h"} = 1;
    $headerIncludes{"ActiveDOMCallback.h"} = 1;
    $headerIncludes{"RBScriptState.h"} = 1;
    foreach my $include (sort keys(%headerIncludes)) {
        push(@headerContentHeader, "#include \"$include\"\n");
    }
    
    push(@headerContent, "namespace WebCore {\n\n");
    push(@headerContent, "class $className : public ${interfaceName}, public RBCallback, public ActiveDOMCallback {\n");
    push(@headerContent, "public:\n");
    push(@headerContent, "    static PassRefPtr<$className> create(VALUE proc, ScriptExecutionContext* context)\n");
    push(@headerContent, "    {\n");
    push(@headerContent, "        return adoptRef(new ${className}(proc, context));\n");
    push(@headerContent, "    }\n\n");
    push(@headerContent, "    virtual ScriptExecutionContext* scriptExecutionContext() const { return ContextDestructionObserver::scriptExecutionContext(); }\n");

    # - FUNCTIONS -
    my @headerFunctions = ();
    foreach my $function (@{$dataNode->functions}) {
        push(@headerContent, "    virtual " . GetCallbackCPPType($function->signature->type) . " " . $function->signature->name . "(");

        my @args = ();
        foreach my $param (@{$function->parameters}) {
            push(@args, GetCallbackCPPType($param->type) . " " . $param->name);
        }
        push(@headerContent, join(", ", @args) . ");\n");
    }

    push(@headerContent, "\nprotected:\n");
    push(@headerContent, "    ${className}(VALUE proc, ScriptExecutionContext*);\n");
    push(@headerContent, "    virtual ~${className}();\n");
    push(@headerContent, "};\n\n");
    push(@headerContent, "inline VALUE toRB(${className}* impl) { return impl->proc(); }\n");
    push(@headerContent, "inline VALUE toRB(PassRefPtr<${className}> impl) { return impl.get()->proc(); }\n\n");
    push(@headerContent, "} // namespace WebCore\n\n");
    push(@headerContent, "#endif // ${conditionalString}\n\n") if $conditionalString;    
    push(@headerContent, "#endif\n");
}

sub GenerateCallbackImplementation
{
    my $object = shift;
    my $dataNode = shift;

    @implContentHeader = split("\r", $implementationLicenseTemplate);

    # - INCLUDES -
    push(@implContentHeader, "\n#include \"config.h\"\n");
    my $conditionalString = $codeGenerator->GenerateConditionalString($dataNode);    
    push(@implContentHeader, "\n#if ${conditionalString}\n\n") if $conditionalString;
    push(@implContentHeader, "#include \"$className.h\"\n\n");
    $implIncludes{"RBObject.h"} = 1;
    $implIncludes{"RBConverters.h"} = 1;
    $implIncludes{"<Ruby/ruby.h>"} = 1;

    @implContent = ();
    push(@implContent, "namespace WebCore {\n\n");

    push(@implContent, "${className}::${className}(VALUE proc, ScriptExecutionContext* context)\n");
    push(@implContent, ": RBCallback(proc)\n");
    push(@implContent, ", ActiveDOMCallback(context)\n");
    push(@implContent, "{\n");
    push(@implContent, "}\n\n");

    push(@implContent, "${className}::~${className}()\n");
    push(@implContent, "{\n");
    push(@implContent, "}\n\n");

    # - FUNCTIONS -
    foreach my $function (@{$dataNode->functions}) {
        AddIncludesForType($function->signature->type);

        my @functionContent = ();
        my $needsCustomImplementation = $function->signature->extendedAttributes->{"Custom"};
        push(@functionContent, GetCallbackCPPType($function->signature->type) . " ${className}::" . $function->signature->name . "(");
        
        my @args = ();
        foreach my $param (@{$function->parameters}) {
            AddIncludesForType($param->type) if !$needsCustomImplementation;
            push(@args, GetCallbackCPPType($param->type) . " " . $param->name);
        }
        push(@functionContent, join(", ", @args) . ")\n");
        push(@functionContent, "{\n");

        my $paramCount = (@{$function->parameters});
        if ($paramCount) {
            push(@functionContent, "    VALUE argv[${paramCount}];\n");
            my $paramI = 0;
            foreach my $param (@{$function->parameters}) {
                push(@functionContent, "    argv[${paramI}] = toRB(" . $param->name . ");\n");
                $paramI++;
            }
            push(@functionContent, "    VALUE result = callProc(scriptExecutionContext(), $paramCount, argv);\n");
        } else {
            push(@functionContent, "    VALUE result = callProc(scriptExecutionContext());\n");
        }

        my $implGetter = RBToNative("result", $function->signature);
        push(@functionContent, "    return $implGetter;\n");
        push(@functionContent, "}\n\n");

        if ($needsCustomImplementation) {
            push(@implCustomContent, @functionContent);
        } else {
            push(@implContent, @functionContent);
        }
    }

    push(@implContent, "} // namespace WebCore\n");
    push(@implContent, "\n#endif // ${conditionalString}\n") if $conditionalString;
    push(@implCustomContent, "} // namespace WebCore\n") if @implCustomContent;
    push(@implCustomContent, "\n#endif // ${conditionalString}\n") if ($conditionalString and @implCustomContent);
}

sub RequiresVariableArguments
{
    my $function = shift;

    return 1 if CountOptionalArguments($function);
    return 1 if $codeGenerator->ExtendedAttributeContains($function->signature->extendedAttributes->{"CallWith"}, "ScriptArguments");

    # FIXME: Change the IDL so that it specifies these correctly.
    return 1 if $function->signature->name eq "set" and $interface->extendedAttributes->{"TypedArray"};
    return 1 if $interfaceName eq "HTMLSelectElement" and $function->signature->name eq "remove";
    return 1 if $interfaceName eq "XMLHttpRequest" and $function->signature->name eq "send";
    return 1 if $interfaceName eq "WorkerContext" and $function->signature->name eq "importScripts";

    # FIXME: The IDL on these functions should be changed so that they have their correct arguments.
    # It doesn't matter in JSC because they can get their arguments from the ExecState.
    # It matters for Ruby, however, because we can't get the arguments.
    if ($interfaceName eq "WebGLRenderingContext") {
        return 1 if $function->signature->name eq "getBufferParameter";
        return 1 if $function->signature->name eq "getTexParameter";
        return 1 if $function->signature->name eq "getVertexAttrib";
        return 1 if $function->signature->name eq "getRenderbufferParameter";
        return 1 if $function->signature->name eq "getShaderParameter";
        return 1 if $function->signature->name eq "getUniform";
        return 1 if $function->signature->name eq "getFramebufferAttachmentParameter";
        return 1 if $function->signature->name eq "getParameter";
        return 1 if $function->signature->name eq "getProgramParameter";
    }

    foreach my $param (@{$function->parameters}) {
        return 1 if $param->isVariadic;
    }

    return 0;
}

sub GenerateHeader
{
    my $object = shift;
    my $dataNode = shift;

    my $rbClassVariable = GetRubyClassVariableName($interfaceName);
    my $parentName = "";
    $parentName = GetParent($dataNode);

    my @ancestorInterfaceNames = ();
    if (@{$dataNode->parents} > 1) {
        die "A class can't have more than one parent" unless $interfaceName =~ /SVG/;
        $codeGenerator->AddMethodsConstantsAndAttributesFromParentInterfaces($interface, \@ancestorInterfaceNames);
    }

    # - Add default header template
    @headerContentHeader = split("\r", $headerLicenseTemplate);
    push(@headerContentHeader, "\n#ifndef $className" . "_h");
    push(@headerContentHeader, "\n#define $className" . "_h\n\n");

    my $conditionalString = $codeGenerator->GenerateConditionalString($dataNode); 
    push(@headerContentHeader, "#if ${conditionalString}\n\n") if $conditionalString;

    # - INCLUDES -
    my %headerIncludes = ();
    if ($codeGenerator->IsTypedArrayType($parentName)) {
        $headerIncludes{"<wtf/$parentName.h>"} = 1;
    } else {
        $headerIncludes{"\"$parentName.h\""} = 1;
    }
    if ($codeGenerator->IsTypedArrayType($interfaceName)) {
        $headerIncludes{"<wtf/$interfaceName.h>"} = 1;
    } elsif ($interfaceName =~ /SVGPathSeg/) {
        my $realName = $interfaceName;
        $realName =~ s/Abs|Rel//;
        $headerIncludes{"\"$realName.h\""} = 1;
    } else {
        $headerIncludes{"\"$interfaceName.h\""} = 1 if !$codeGenerator->SkipIncludeHeader($interfaceName);
    }

    my $svgType = $codeGenerator->GetSVGTypeNeedingTearOff($interfaceName);
    if ($svgType) {
        my $svgWrappedType = $codeGenerator->GetSVGWrappedTypeNeedingTearOff($interfaceName);
        $headerIncludes{"\"$svgWrappedType.h\""} = 1;
        if ($svgType =~ /SVGPropertyTearOff/) {
            $headerIncludes{"\"SVGAnimatedPropertyTearOff.h\""} = 1;
        } elsif ($svgType =~ /SVGListPropertyTearOff/ or $svgType =~ /SVGStaticListPropertyTearOff/) {
            $headerIncludes{"\"SVGAnimatedListPropertyTearOff.h\""} = 1;
        } elsif ($svgType =~ /SVGTransformListPropertyTearOff/) {
            $headerIncludes{"\"SVGAnimatedListPropertyTearOff.h\""} = 1;
            $headerIncludes{"\"SVGTransformListPropertyTearOff.h\""} = 1;
        } elsif ($svgType =~ /SVGPathSegListPropertyTearOff/) {
            $headerIncludes{"\"SVGAnimatedListPropertyTearOff.h\""} = 1;
            $headerIncludes{"\"SVGPathSegListPropertyTearOff.h\""} = 1;
        }
    }
    
    $headerIncludes{"<Ruby/ruby.h>"} = 1;
    $headerIncludes{"\"RBDOMBindingAttributes.h\""} = 1;
    foreach my $include (sort keys(%headerIncludes)) {
        push(@headerContentHeader, "#include $include\n");
    }
    
    push(@headerContent, "namespace WebCore {\n\n");
    push(@headerContent, "class $className");
    push(@headerContent, " : public $parentName") if $parentName;
    push(@headerContent, " {\n");
    push(@headerContent, "public:\n");
    
    # For Ruby, the C++ class isn't actually instantiated.
    # The header file will include the "Init_ClassName" function,
    # which defines the class in the Ruby interpreter.
    my $rbParentClass = $parentName . "::rubyClass()";
    if ($dataNode->isException) {
        $rbParentClass = "rb_eException";
    }
    my $rubyClassName = GetRubyClassName($dataNode);
    push(@rbInitFunction, "    /*\n");
    push(@rbInitFunction, "     * Initializes the class in the Ruby interpreter.\n");    
    push(@rbInitFunction, "     * This function needs to be called before using this class in Ruby.\n");
    push(@rbInitFunction, "     */\n");
    push(@rbInitFunction, "    static void Init_${interfaceName}() {\n");
    push(@rbInitFunction, "        static bool defined = false;\n");
    push(@rbInitFunction, "        if (defined)\n");
    push(@rbInitFunction, "            return;\n");
    push(@rbInitFunction, "        defined = true;\n\n");
    push(@rbInitFunction, "        $rbClassVariable = rb_define_class(\"$rubyClassName\", $rbParentClass);\n");
    push(@rbInitFunction, "        rb_extend_object($rbClassVariable, RBDOMBindingAttributes::rubyClass());\n\n");

    # The Ruby DOM objects should not be able to use 'dup' and 'clone'
    push(@rbInitFunction, "        // DOM objects do not implement 'dup' or 'clone'\n");
    push(@rbInitFunction, "        rb_undef_method($rbClassVariable, \"dup\");\n");
    push(@rbInitFunction, "        rb_undef_method($rbClassVariable, \"clone\");\n\n");

    # - CONSTRUCTORS -
    # A single constructor with 0 arguments get a zero argument method.
    # A constructor template gets a fixed number of arguments.
    # Any other constructor gets a variable number of arguments.
    # FIXME: Handle NamedConstructor
    my @constructors = @{$dataNode->constructors};
    my $customConstructor = $dataNode->extendedAttributes->{"CustomConstructor"};
    my $constructorTemplate = $dataNode->extendedAttributes->{"ConstructorTemplate"};
    if ($constructorTemplate and $constructorTemplate eq "Event") {
        push(@rbInitFunction, "        rb_define_singleton_method(${rbClassVariable}, \"new\", RUBY_METHOD_FUNC(&${className}::rb_new), -1);\n\n");
        push(@headerContent, "    static void fillEventInit(${interfaceName}Init&, VALUE options);\n");
        push(@headerContent, "    static VALUE rb_new(int argc, VALUE* argv, VALUE self);\n");
    } elsif ($constructorTemplate and $constructorTemplate eq "TypedArray") {
        push(@rbInitFunction, "        rb_define_singleton_method(${rbClassVariable}, \"new\", RUBY_METHOD_FUNC(&${className}::rb_new), -1);\n\n");
        push(@headerContent, "    static VALUE rb_new(int argc, VALUE* argv, VALUE self);\n");
    } elsif ((@constructors or $customConstructor) and !$dataNode->extendedAttributes->{"NamedConstructor"}) {
        if (@constructors == 1 && !(@{$constructors[0]->parameters})) {
            push(@rbInitFunction, "        rb_define_singleton_method(${rbClassVariable}, \"new\", RUBY_METHOD_FUNC(&${className}::rb_new), 0);\n\n");
            push(@headerContent, "    static VALUE rb_new(VALUE);\n");
        } else {
            push(@rbInitFunction, "        rb_define_singleton_method(${rbClassVariable}, \"new\", RUBY_METHOD_FUNC(&${className}::rb_new), -1);\n\n");
            push(@headerContent, "    static VALUE rb_new(int argc, VALUE* argv, VALUE);\n");
        }
    } elsif (!$dataNode->extendedAttributes->{"NamedConstructor"}) {
        push(@rbInitFunction, "        rb_define_singleton_method(${rbClassVariable}, \"new\", RUBY_METHOD_FUNC(&${className}::rb_new), 0);\n\n");
        push(@headerContent, "    static VALUE rb_new(VALUE self);\n");
    }

    # - CONSTANTS -
    # These constants will be defined in the Ruby class, not the C++ class.
    # Convert the values of the constants to Ruby types.
    my @headerConstants = ();
    my @constants = @{$dataNode->constants};
    foreach my $constant (@constants) {
        my $constantName = $constant->name;
        my $constantValue = $constant->value;
        my $conditional = $constant->extendedAttributes->{"Conditional"};
        my $conditionalString = $codeGenerator->GenerateConditionalStringFromAttributeValue($conditional) if $conditional;
        push(@headerConstants, "#if ${conditionalString}\n") if $conditionalString;
        push(@headerConstants, "        rb_define_const(${rbClassVariable}, \"${constantName}\", INT2FIX(${constantValue}));\n");
        push(@headerConstants, "\n#endif\n") if $conditional;
    }
    
    if (@headerConstants > 0) {
        push(@rbInitFunction, "        // Define the constants in the Ruby class.\n");
        push(@rbInitFunction, @headerConstants);
        push(@rbInitFunction, "\n");
    }

    # - ATTRIBUTES -
    # We need to define a getter and setter function for each attribute.
    # Add 'rb_define_method' to the Init function static function to the class.
    # We could use rb_define_attr, but we need the custom getter and setter anyway.
    my @headerAttributes = ();
    my @headerAttributeFunctions = ();
    foreach my $attribute (@{$dataNode->attributes}) {
        next if SkipAttribute($attribute);
    
        my $attributeConditionalString = $codeGenerator->GenerateConditionalString($attribute->signature);
        my $attributeName = $attribute->signature->name;
        my $rbAttributeName = GetRubyFunctionName($attributeName);
        my $attributeIsReadonly = ($attribute->type =~ /^readonly/);
        my $createSetter = !($attributeIsReadonly or $attribute->signature->extendedAttributes->{"Replaceable"});            
        my $getterName = GetRubyFunctionName($attributeName) . "_getter";
        my $setterName = GetRubyFunctionName($attributeName . "Setter");
        
        my $property = "";
        my $rbDefineFunction = $attribute->isStatic ? "rb_define_singleton_method" : "rb_define_method";
        $property .= "#if ${attributeConditionalString}\n" if $attributeConditionalString;
        $property .= "        ${rbDefineFunction}(${rbClassVariable}, \"${rbAttributeName}\", RUBY_METHOD_FUNC(&${className}::$getterName), 0);\n";
        $property .= "        ${rbDefineFunction}(${rbClassVariable}, \"${rbAttributeName}=\", RUBY_METHOD_FUNC(&${className}::$setterName), 1);\n" if $createSetter;
        $property .= "        rb_funcall(${rbClassVariable}, rb_intern(\"add_dom_binding_attribute\"), 1, rb_str_new2(\"${rbAttributeName}\"));\n";
        $property .= "#endif\n" if $attributeConditionalString;
        push(@headerAttributes, $property);
        
        push(@headerAttributeFunctions, "#if ${attributeConditionalString}\n") if $attributeConditionalString;
        push(@headerAttributeFunctions, "    static VALUE $getterName(VALUE self);\n");
        push(@headerAttributeFunctions, "    static VALUE $setterName(VALUE self, VALUE newValue);\n") if $createSetter;            
        push(@headerAttributeFunctions, "#endif\n") if $attributeConditionalString;
    }
    
    if (@headerAttributes > 0) {
        push(@rbInitFunction, "        // Attributes\n");
        push(@rbInitFunction, @headerAttributes);
        push(@rbInitFunction, "\n");
        
        push(@headerContent, "\n");
        push(@headerContent, "    // Attributes\n");
        push(@headerContent, @headerAttributeFunctions);
    }

    # - FUNCTIONS -
    # These functions are defined in the Ruby class and as static methods of the C++ class.
    # We call 'rb_define_method' in the 'Init' function and point it to a static function that implements it.
    my @headerFunctions = ();
    my @rbHeaderFunctions = ();
    foreach my $function (@{$dataNode->functions}) {
        next if SkipFunction($function);
        next if $function->{overloadIndex} and $function->{overloadIndex} > 1;
        
        # Generate the static method signature.
        my $functionName = $function->signature->name;
        $functionName = "to_s" if $functionName eq "toString";
        my $numberOfParameters = @{$function->parameters};
        my $staticFunctionName = GetStaticFunctionName($functionName);
        my $functionSig;
        my $isOverloaded = $function->{overloads} && @{$function->{overloads}} > 1;
        if (RequiresVariableArguments($function) || $isOverloaded) {
            $numberOfParameters = -1;
            $functionSig = "    static VALUE $staticFunctionName(int argc, VALUE* argv, VALUE self)";
        } else {
            $functionSig = "    static VALUE $staticFunctionName(VALUE self";
            foreach my $param (@{$function->parameters}) {
                $functionSig .= ", VALUE " . $param->name;
            }
            $functionSig .= ")";
        }
        
        my $conditionalString = $codeGenerator->GenerateConditionalString($function->signature);
        push(@headerFunctions, "#if ${conditionalString}\n") if $conditionalString;
        push(@headerFunctions, "${functionSig};\n");
        push(@headerFunctions, "#endif\n") if $conditionalString;
        
        # Add this function to the class initialization function.
        $rbFunctionName = GetRubyFunctionName($functionName);
        my $rbDefineFunction = $function->isStatic ? "rb_define_singleton_method" : "rb_define_method";
        $defineMethod = "        ${rbDefineFunction}(${rbClassVariable}, \"${rbFunctionName}\", RUBY_METHOD_FUNC(&${className}::${staticFunctionName}), ${numberOfParameters});\n";
        push(@rbHeaderFunctions, "#if ${conditionalString}\n") if $conditionalString;
        push(@rbHeaderFunctions, $defineMethod);
        push(@rbHeaderFunctions, "#endif\n") if $conditionalString;
    }

    if (@headerFunctions > 0) {
        push(@headerContent, "\n");
        push(@headerContent, "    // Functions\n");
        push(@headerContent, @headerFunctions);
        
        push(@rbInitFunction, "        // Functions\n");
        push(@rbInitFunction, @rbHeaderFunctions);
    }
    
    # - INDEXED/NAMED GETTER/SETTER -
    # The [] and []= methods will be used to call the indexed and named getters and setters.
    # The method_missing method will be used for named getter and setters.
    # If there's an indexed getter, also include the enumerable module.
    if ($dataNode->extendedAttributes->{"IndexedGetter"} || $dataNode->extendedAttributes->{"NumericIndexedGetter"}) {
        push(@headerContent, "    static VALUE indexed_getter(VALUE self, VALUE index);\n");
        push(@headerContent, "    static VALUE each(VALUE self);\n");
        push(@rbInitFunction, "        rb_include_module(${rbClassVariable}, rb_mEnumerable);\n");
        push(@rbInitFunction, "        rb_define_method(${rbClassVariable}, \"each\", RUBY_METHOD_FUNC(&${className}::each), 0);\n"); 
    }
    if ($dataNode->extendedAttributes->{"CustomIndexedSetter"}) {
        push(@headerContent, "    static VALUE indexed_setter(VALUE self, VALUE index, VALUE value);\n");
    }
    if ($dataNode->extendedAttributes->{"NamedGetter"} || $dataNode->extendedAttributes->{"CustomNamedGetter"}) {
        push(@headerContent, "    static VALUE named_getter(VALUE self, VALUE name);\n");
    }
    if ($dataNode->extendedAttributes->{"CustomNamedSetter"}) {
        push(@headerContent, "    static VALUE named_setter(VALUE self, VALUE name, VALUE value);\n");
    }
    if ($dataNode->extendedAttributes->{"IndexedGetter"}
        || $dataNode->extendedAttributes->{"NumericIndexedGetter"}
        || $dataNode->extendedAttributes->{"NamedGetter"}
        || $dataNode->extendedAttributes->{"CustomNamedGetter"}) {
        push(@headerContent, "    static VALUE square_brackets(VALUE self, VALUE key);\n");
        push(@rbInitFunction, "        rb_define_method(${rbClassVariable}, \"[]\", RUBY_METHOD_FUNC(&${className}::square_brackets), 1);\n");
    }
    if ($dataNode->extendedAttributes->{"CustomIndexedSetter"}
        || $dataNode->extendedAttributes->{"CustomNamedSetter"}) {
        push(@headerContent, "    static VALUE square_brackets_equals(VALUE self, VALUE key, VALUE value);\n");
        push(@rbInitFunction, "        rb_define_method(${rbClassVariable}, \"[]=\", RUBY_METHOD_FUNC(&${className}::square_brackets_equals), 2);\n");
    }
    if ($dataNode->extendedAttributes->{"NamedGetter"} 
        || $dataNode->extendedAttributes->{"CustomNamedGetter"}
        || $dataNode->extendedAttributes->{"CustomNamedSetter"}) {
        push(@headerContent, "    static VALUE method_missing(int argc, VALUE* argv, VALUE self);\n");
        push(@rbInitFunction, "        rb_define_method(${rbClassVariable}, \"method_missing\", RUBY_METHOD_FUNC(&${className}::method_missing), -1);\n");
    }

    # Override the '==' function with one that checks equality between two implementations.
    push(@headerContent, "    static VALUE operator_equals(VALUE self, VALUE other);\n");
    push(@rbInitFunction, "        rb_define_method(${rbClassVariable}, \"==\", RUBY_METHOD_FUNC(&${className}::operator_equals), 1);\n");
    
    # Complete the Ruby class initialization function and add it to the header content.
    push(@rbInitFunction, "    }\n\n");
    push(@headerContent, "\n");
    push(@headerContent, @rbInitFunction);
    
    # Add class variable getter and property.
    push(@headerContent, "    static VALUE rubyClass() {\n");
    push(@headerContent, "        Init_${interfaceName}();\n");
    push(@headerContent, "        return ${rbClassVariable};\n");
    push(@headerContent, "    }\n\n");
    push(@headerContent, "private:\n");
    push(@headerContent, "    static VALUE ${rbClassVariable};\n");
    push(@headerContent, "};\n\n");
    
    # Add the function to convert to Ruby.
    my $pointerType = $interfaceName;
    my $passRefPtrType = "PassRefPtr<${interfaceName}>";
    if ($codeGenerator->IsSVGTypeNeedingTearOff($interfaceName)) {
        $pointerType = $codeGenerator->GetSVGTypeNeedingTearOff($interfaceName);
        $passRefPtrType = "PassRefPtr<${pointerType} >";
    }
    push(@headerContent, "VALUE toRB($pointerType*);\n");
    push(@headerContent, "inline VALUE toRB($passRefPtrType refPtr) { return toRB(refPtr.get()); }\n\n");

    push(@headerContent, "} // namespace WebCore\n\n");
    push(@headerContent, "#endif // ${conditionalString}\n\n") if $conditionalString;    
    push(@headerContent, "#endif\n");
}

sub GenerateTypedArraySetImplementation
{
    my @functionContent = ();
    $implIncludes{"RBArrayBufferViewHelper.h"} = 1;
    push(@functionContent, "VALUE ${className}::set(int argc, VALUE* argv, VALUE self)\n");
    push(@functionContent, "{\n");
    push(@functionContent, "    $implSelfDeclaration;\n");
    push(@functionContent, "    setTypedArrayHelper<$interfaceName>(argc, argv, $implSelf);\n");
    push(@functionContent, "    return Qnil;\n");
    push(@functionContent, "}\n\n");
    return @functionContent;
}

sub GenerateFunctionImplementation
{
    my $function = shift;

    if ($function->signature->name eq "set" and $interface->extendedAttributes->{"TypedArray"}) {
        return GenerateTypedArraySetImplementation();
    }

    my $functionName = $function->signature->extendedAttributes->{"ImplementedAs"} || $function->signature->name;
    my $rubyFunctionName = $function->signature->name eq "toString" ? "to_s" : $function->signature->name;
    my $staticFunctionName = GetStaticFunctionName($rubyFunctionName);
    my $functionSig;
    if ($function->{overloads} and @{$function->{overloads}} > 1) {
        $functionSig = "static VALUE $staticFunctionName" . $function->{overloadIndex};
    } else {
        $functionSig = "VALUE ${className}::$staticFunctionName";
    }

    my $needsCustomImplementation = NeedsCustomImplementation($function);
    AddIncludesForType($function->signature->type) if !$needsCustomImplementation;
    my $raisesExceptions = @{$function->raisesExceptions};
    my @params = @{$function->parameters};
    my @functionContent = ();
    my @optionalContent = ();
    my @parameterNames = ();
    my @callWithArgs = GenerateCallWith($function->signature->extendedAttributes->{"CallWith"}, \@functionContent, $function);
    push(@parameterNames, @callWithArgs);

    my $optionalCount = CountOptionalArguments($function);
    my $mandatoryCount = @params - $optionalCount;
    my $hasScriptArguments = $codeGenerator->ExtendedAttributeContains($function->signature->extendedAttributes->{"CallWith"}, "ScriptArguments");
    my $hasVariableArguments = RequiresVariableArguments($function);
    if ($hasVariableArguments) {
        $functionSig .= "(int argc, VALUE* argv, VALUE" . ($function->isStatic ? ")" : " self)");
    } else {
        $functionSig .= "(VALUE" . ($function->isStatic ? "" : " self");
    }

    my $hasVariadic = 0;
    foreach my $param (@params) {
        next if !$param->isVariadic;
        $hasVariadic = 1;
        $mandatoryCount -= 1;
    }

    my $argDeclaration = "VALUE ";
    my $scanArgs = "rb_scan_args(argc, argv, \"${mandatoryCount}${optionalCount}" . ($hasVariadic ? "*\"" : "\"");
    my $remainingParams = $mandatoryCount + $optionalCount + ($hasVariadic ? 1 : 0);
    my $callbackCount = 0;
    foreach my $param (@params) {
        my $paramName = $param->name;
        my $paramType = $param->type;
        my $paramImplConverter = RBToNative($paramName, $param);
        my $paramImplName = "${paramName}Impl";
        my $paramNativeType = GetNativeType($paramType);
        if ($param->isVariadic) {
            if ($paramNativeType =~ />/) {
                $paramNativeType = "$paramNativeType ";
            } elsif ($paramType eq "DOMString") {
                $paramNativeType = "String";
            }
            $paramImplConverter = "rbToNativeArray<$paramNativeType>($paramName)";
            $paramNativeType = "Vector<$paramNativeType>";
        }
        if ($codeGenerator->IsSVGTypeNeedingTearOff($paramType) and !($interfaceName =~ /List$/)) {
            $paramNativeType = $codeGenerator->GetSVGWrappedTypeNeedingTearOff($paramType) . "&";
        }
        my $paramImplDeclaration = "$paramNativeType $paramImplName = $paramImplConverter";

        AddIncludesForType($paramType) if !NeedsCustomImplementation($function);

        # If this is the first callback, check if it's supplied in the implicit block.
        # If it is, then the other parameters will be in the wrong order.
        if (IsCallback($param)) {
            $callbackCount++;
            if ($callbackCount == 1) {
                my $lastArgI = $mandatoryCount + $optionalCount - 1;
                my $thisArgI = $lastArgI - $remainingParams + 1;
                push(@functionContent, "    if (rb_block_given_p())" . ($lastArgI != $thisArgI ? " {\n" : "\n"));
                for (my $i = $lastArgI; $i > $thisArgI; $i--) {
                    my $fromParam = $params[$i - 1]->name;
                    my $toParam = $params[$i]->name;
                    push(@functionContent, "        ${toParam} = ${fromParam};\n");
                }
                push(@functionContent, "        $paramName = rb_block_proc();\n");
                push(@functionContent, "    " . ($lastArgI != $thisArgI ? "}\n" : "\n"));
            }
        }

        $remainingParams--;
        $argDeclaration .= $paramName . (!$remainingParams ? ";" : ", ");
        $scanArgs .= ", &${paramName}";

        if (!$hasVariableArguments) {
            $functionSig .= ", VALUE $paramName";
            push(@functionContent, "    $paramImplDeclaration;\n")
        } else {
            my $option = $param->extendedAttributes->{"Optional"};
            if ($option 
                and $option ne "DefaultIsNullString" 
                and $option ne "DefaultIsUndefined" 
                and $paramType ne "Dictionary" 
                and !$param->extendedAttributes->{"Callback"}
                and $functionName ne "addEventListener" 
                and $functionName ne "removeEventListener") {

                # If there's a purely optional argument that isn't supplied, then generate an early call and return.
                push(@optionalContent, "    if (NIL_P(${paramName})) {\n");

                push(@parameterNames, "ec") if $raisesExceptions;
                my $earlyCall = $codeGenerator->WK_lcfirst($functionName) . "(" . join(", ", @parameterNames) . ")";
                if ($function->isStatic) {
                    $earlyCall = "${interfaceName}::${earlyCall}";
                } else {
                    $earlyCall = "$implSelf->${earlyCall}";
                }
                pop(@parameterNames) if $raisesExceptions;

                if ($codeGenerator->IsSVGTypeNeedingTearOff($function->signature->type)) {
                    $earlyCall = WrapWithSVGConverter($function->signature, $earlyCall);
                } elsif ($function->signature->type eq "Date") {
                    $earlyCall .= ", Date";
                }

                $earlyCall = "VALUE result = toRB(${earlyCall})" if $function->signature->type ne "void";
                push(@optionalContent, "        ${earlyCall};\n");
                if ($codeGenerator->IsSVGTypeNeedingTearOff($interfaceName) and !$function->isStatic and !($interfaceName =~ /List/)) {
                    if ($raisesExceptions) {
                        push(@optionalContent, "        if (!ec)\n");
                        push(@optionalContent, "            $svgSelf->commitChange();\n");
                    } else {
                        push(@optionalContent, "        $svgSelf->commitChange();\n");
                    }
                }
                push(@optionalContent, "        $exceptionRaiseOnError\n") if $raisesExceptions;
                if ($function->signature->type eq "void") {
                    push(@optionalContent, "        return Qnil;\n");
                } else {
                    push(@optionalContent, "        return result;\n");
                }
                push(@optionalContent, "    }\n");
                push(@optionalContent, "    $paramImplDeclaration;\n");
            } else {
                push(@functionContent, "    $paramImplDeclaration;\n")
            }
        }

        if ($paramType eq "EventListener" and $functionName eq "removeEventListener") {
            push(@parameterNames, "$paramImplName.get()");
        } else {
            push(@parameterNames, $paramImplName);
        }        

        # FIXME: Remove "DOMObject" from this if.
        push(@optionalContent, "    UNUSED_PARAM(${paramName});\n") if ($paramType eq "DOMObject" or $needsCustomImplementation);
    }

    if ($optionalCount || $hasScriptArguments) {
        push(@functionContent, @optionalContent);
    } elsif (!$hasVariableArguments) {
        $functionSig .= ")" if !$remainingParams;
    }

    push(@parameterNames, "ec") if $raisesExceptions;

    my $implementedBy = $function->signature->extendedAttributes->{"ImplementedBy"};
    unshift(@parameterNames, $implSelf) if $implementedBy;
    my $content = $codeGenerator->WK_lcfirst($functionName) . "(" . join(", ", @parameterNames) . ")";
    if ($implementedBy) {
        $implIncludes{"${implementedBy}.h"} = 1;
        $content = "${implementedBy}::${content}";
    } elsif ($function->isStatic) {
        $content = "${interfaceName}::${content}";
    } else {
        $content = "$implSelf->${content}";
    }

    if ($codeGenerator->IsSVGTypeNeedingTearOff($function->signature->type)) {
        $content = WrapWithSVGConverter($function->signature, $content);
    }
    
    if ($needsCustomImplementation) {
        push(@functionContent, "    $notImplementedFixme\n");
        push(@functionContent, "    $notImplementedRaise\n");
        push(@functionContent, "    return Qnil;\n");
    } else {
        if ($function->signature->type ne "void") {
            $content .= ", false" if $function->signature->extendedAttributes->{"TreatReturnedNullStringAs"};
            $content .= ", Date" if $function->signature->type eq "Date";
            $content = "VALUE result = toRB(${content})";
        }
        
        push(@functionContent, "    $content;\n");
        if ($codeGenerator->IsSVGTypeNeedingTearOff($interfaceName) and !$function->isStatic and !($interfaceName =~ /List/)) {
            if ($raisesExceptions) {
                push(@functionContent, "    if (!ec)\n");
                push(@functionContent, "        $svgSelf->commitChange();\n");
            } else {
                push(@functionContent, "    $svgSelf->commitChange();\n");
            }
        }
        push(@functionContent, "    $exceptionRaiseOnError\n") if $raisesExceptions;
        
        # FIXME: Should we return "self" if the return type is void?
        if ($function->signature->type eq "void") {
            push(@functionContent, "    return Qnil;\n");
        } else {
            push(@functionContent, "    return result;\n");
        }
    }
    
    my $conditionalString = $codeGenerator->GenerateConditionalString($function->signature);
    my @functionHeaderContent = ();
    push(@functionHeaderContent, "#if ${conditionalString}\n") if $conditionalString;
    push(@functionHeaderContent, "$functionSig\n");
    push(@functionHeaderContent, "{\n");
    push(@functionHeaderContent, "    $implSelfDeclaration;\n") if !$function->isStatic;
    if ($hasVariableArguments && @{$function->parameters}) {
        push(@functionHeaderContent, "    $argDeclaration\n");
        push(@functionHeaderContent, "    $scanArgs);\n");
    }
    push(@functionHeaderContent, "    $exceptionInit\n") if $raisesExceptions;
    push(@functionHeaderContent, GenerateSecurityChecks($function, 1));
    unshift(@functionContent, @functionHeaderContent);
    push(@functionContent, "}\n"); 
    push(@functionContent, "#endif\n") if $conditionalString;
    push(@functionContent, "\n");

    return @functionContent;
}

sub GetTypeChecker
{
    my $paramName = shift;
    my $param = shift;
    my $type = $param->type;

    return "IS_RB_STRING($paramName)" if $codeGenerator->IsStringType($type);
    return "IS_RB_BOOL($paramName)" if $type eq "boolean";
    return "IS_RB_NUM($paramName)" if $type eq "double" or $type eq "float";
    return "IS_RB_NUM($paramName)" if $codeGenerator->IsPrimitiveType($type);
    return "IS_RB_HASH($paramName)" if $type eq "Dictionary";
    return "IS_RB_ARRAY($paramName)" if $codeGenerator->GetSequenceType($type) or $codeGenerator->GetArrayType($type);
    return "IS_RB_KIND($paramName, $type)";
}

sub GenerateConstructorImplementation
{
    my $dataNode = shift;
    my @constructors = @{$dataNode->constructors};
    if (!@constructors) {
        my $rubyClassName = GetRubyClassName($dataNode);
        my $constructor = << "EOF";
VALUE ${className}::rb_new(VALUE)
{
    rb_raise(rb_eNoMethodError, "Cannot construct a new ${rubyClassName}.");
    return Qnil;
}

EOF
        return $constructor;
    }

    my $needsCustomImplementation = $dataNode->extendedAttributes->{"CustomConstructor"};
    my $customParameterCount = $dataNode->extendedAttributes->{"ConstructorParameters"};

    my $raisesExceptions = $dataNode->extendedAttributes->{"ConstructorRaisesException"};
    my @constructorContent = ();
    push(@constructorContent, "    $exceptionInit\n\n") if $raisesExceptions;

    my @callWithArgs = GenerateCallWith($dataNode->extendedAttributes->{"CallWith"}, \@constructorContent);

    my $constructorSig;
    if (($needsCustomImplementation and $customParameterCount == 0) or (@constructors == 1 && !(@{$constructors[0]->parameters}))) {
        $constructorSig =  "VALUE ${className}::rb_new(VALUE)";
        $parameterList = join(", ", @callWithArgs);
        push(@constructorContent, "    return toRB(${interfaceName}::create($parameterList));\n") if !$needsCustomImplementation;
    } else {
        $constructorSig =  "VALUE ${className}::rb_new(int argc, VALUE* argv, VALUE)";

        my $mandatoryArgs = 99;
        my $totalArgs = 0;
        foreach my $constructor (@constructors) {
            my $optional = CountOptionalArguments($constructor);
            my $mandatory = (@{$constructor->parameters}) - $optional;
            $mandatoryArgs = $mandatory if $mandatory < $mandatoryArgs;
            $totalArgs = (@{$constructor->parameters}) if (@{$constructor->parameters}) > $totalArgs;
        }
        my $optionalArgs = $totalArgs - $mandatoryArgs;
        my $argDeclaration = "VALUE arg0";
        $argDeclaration .= ", arg$_" for (1..($totalArgs - 1));
        my $scanArgs = "int argCount = rb_scan_args(argc, argv, \"${mandatoryArgs}${optionalArgs}\"";
        $scanArgs .= ", &arg$_" for (0..($totalArgs - 1));
        push(@constructorContent, "    $argDeclaration;\n");
        push(@constructorContent, "    $scanArgs);\n\n");

        foreach my $constructor (@constructors) {
            next if SkipFunction($constructor);

            my @parameters = @{$constructor->parameters};
            my $overloadConditional = "    if (argCount == " . (@parameters);
            my @parameterNames = ();
            push(@parameterNames, @callWithArgs);
            foreach (0..(@parameters - 1)) {
                my $paramName = "arg$_";
                my $param = $parameters[$_];
                my $idlType = $param->type;
                my $implGetter = RBToNative($paramName, $param);

                my $typeChecker = GetTypeChecker($paramName, $param);
                $overloadConditional .= " && $typeChecker";

                # FIXME: Add early return for purely optional attributes.
                my $option = $param->extendedAttributes->{"Optional"};
                if ($option and $option eq "DefaultIsNullString") {
                    $implGetter = "rbStringOrNullString($paramName)";
                } elsif ($option and $option eq "DefaultIsUndefined" and $codeGenerator->IsStringType($idlType)) {
                    $implGetter = "rbStringOrUndefined($paramName)";
                } elsif ($option and $option eq "DefaultIsUndefined" and $codeGenerator->IsPrimitiveType($idlType)) {
                    $implGetter = "NIL_P($paramName) ? 0 : $implGetter";
                }
                push(@parameterNames, $implGetter);
            }

            push(@parameterNames, "ec") if $raisesExceptions;
            push(@constructorContent, "$overloadConditional)");
            my $content = "toRB(${interfaceName}::create(" . join(", ", @parameterNames) . "));\n";
            if ($raisesExceptions) {
                push(@constructorContent, " {\n");
                push(@constructorContent, "        VALUE result = $content");
                push(@constructorContent, "        $exceptionRaiseOnError\n") if $raisesExceptions;
                push(@constructorContent, "        return result;\n");
                push(@constructorContent, "    }\n\n");
            } else {
                push(@constructorContent, "\n        return $content\n\n");
            }
        }

        push(@constructorContent, "    return Qnil;\n");
    }
    
    unshift(@constructorContent, "$constructorSig\n{\n");
    push(@constructorContent, "    $notImplementedFixme\n") if $needsCustomImplementation;
    push(@constructorContent, "    $notImplementedRaise\n") if $needsCustomImplementation;
    push(@constructorContent, "}\n\n");
    return @constructorContent;
}

sub GenerateTypedArrayConstructorImplementation
{
    my $dataNode = shift;
    my @constructorContent = ();

    $implIncludes{"RBArrayBufferViewHelper.h"} = 1;
    my $viewType = $dataNode->extendedAttributes->{"TypedArray"};
    push(@constructorContent, "VALUE ${className}::rb_new(int argc, VALUE* argv, VALUE)\n");
    push(@constructorContent, "{\n");
    push(@constructorContent, "    return toRB(createArrayBufferView<${interfaceName}, ${viewType}>(argc, argv));\n");
    push(@constructorContent, "}\n\n");

    return @constructorContent;
}

sub GenerateEventConstructorImplementation
{
    my $dataNode = shift;
    my $customParameterCount = $dataNode->extendedAttributes->{"ConstructorParameters"};
    my @constructorContent = ();

    # Constructor
    push(@constructorContent, "VALUE ${className}::rb_new(int argc, VALUE* argv, VALUE)\n");
    push(@constructorContent, "{\n");
    push(@constructorContent, "    VALUE type, options;\n");
    push(@constructorContent, "    rb_scan_args(argc, argv, \"11\", &type, &options);\n\n");
    push(@constructorContent, "    ${interfaceName}Init eventInit;\n");
    push(@constructorContent, "    fillEventInit(eventInit, options);\n");
    push(@constructorContent, "    String typeString = rbToString(type);\n");
    push(@constructorContent, "    return toRB(${interfaceName}::create(typeString, eventInit));\n");
    push(@constructorContent, "}\n\n");

    # EventInit filler
    push(@constructorContent, "void RB${interfaceName}::fillEventInit(${interfaceName}Init& eventInit, VALUE options)\n");
    push(@constructorContent, "{\n");
    push(@constructorContent, "    if (NIL_P(options))\n");
    push(@constructorContent, "        return;\n\n");

    foreach my $interfaceBase (@{$dataNode->parents}) {
        push(@constructorContent, "    RB${interfaceBase}::fillEventInit(eventInit, options);\n");
    }
    push(@constructorContent, "\n") if @{$dataNode->parents};
    

    foreach my $attribute (@{$dataNode->attributes}) {
        if ($attribute->signature->extendedAttributes->{"InitializedByEventConstructor"}) {
            my $attributeName = $attribute->signature->name;
            my $decamelizedName = Decamelize($attributeName);
            push(@constructorContent, "    VALUE ${attributeName} = rb_hash_aref(options, ID2SYM(rb_intern(\"${decamelizedName}\")));\n");
            push(@constructorContent, "    if (!NIL_P(${attributeName}))\n");
            AddIncludesForType($attribute->signature->type);
            my $implGetter = RBToNative($attributeName, $attribute->signature);
            push(@constructorContent, "        eventInit.${attributeName} = ${implGetter};\n");
        }
    }
    push(@constructorContent, "}\n\n");

    # FIXME: Do something about the 'track' attribute of TrackEvent's TrackEventInit.
    $implIncludes{"RBTrackCustom.h"} = 1 if $interfaceName eq "TrackEvent";

    return @constructorContent;
}

sub GenerateGetterSetterImplementation
{
    my $dataNode = shift;

    my @getterSetterContent = ();

    # IndexedGetter
    if ($dataNode->extendedAttributes->{"IndexedGetter"} || $dataNode->extendedAttributes->{"NumericIndexedGetter"}) {
        push(@getterSetterContent, "VALUE ${className}::indexed_getter(VALUE self, VALUE index)\n");
        push(@getterSetterContent, "{\n");
        push(@getterSetterContent, "    $implSelfDeclaration;\n");
        push(@getterSetterContent, "    return toRB($implSelf->item(NUM2UINT(index)));\n");
        push(@getterSetterContent, "}\n\n");

        push(@getterSetterContent, "VALUE ${className}::each(VALUE self)\n");
        push(@getterSetterContent, "{\n");
        push(@getterSetterContent, "    $implSelfDeclaration;\n");
        push(@getterSetterContent, "    for (size_t i = 0; i < $implSelf->length(); i++)\n");
        push(@getterSetterContent, "        rb_yield(toRB($implSelf->item(i)));\n");
        push(@getterSetterContent, "    return self;\n");
        push(@getterSetterContent, "}\n\n");
    }

    # NamedGetter
    if ($dataNode->extendedAttributes->{"NamedGetter"}) {
        # FIXME: Some named getter implementations have different names in WebCore. The WebCore classes should be modified.
        my %namedGetterHasException = ( "Storage" => 1 );
        my %namedGetterNames = ( "DOMStringMap" => "item", "NamedNodeMap" => "getNamedItem", "StyleSheetList" => "getNamedItem", "Storage" => "getItem" );
        my $generateException = $namedGetterHasException{$interfaceName};
        my $callSignature = $namedGetterNames{$interfaceName} ? $namedGetterNames{$interfaceName} : "namedItem";
        $callSignature .= "(rbToString(name)" . ($generateException ? ", ec" : "") . ")";
        push(@getterSetterContent, "VALUE ${className}::named_getter(VALUE self, VALUE name)\n");
        push(@getterSetterContent, "{\n");
        push(@getterSetterContent, "    $implSelfDeclaration;\n");
        push(@getterSetterContent, "    $exceptionInit\n") if $generateException;
        push(@getterSetterContent, "    VALUE result = toRB($implSelf->$callSignature);\n");
        push(@getterSetterContent, "    $exceptionRaiseOnError\n") if $generateException;
        push(@getterSetterContent, "    return result;\n");
        push(@getterSetterContent, "}\n\n");
    }

    # []
    if ($dataNode->extendedAttributes->{"IndexedGetter"}
        || $dataNode->extendedAttributes->{"NumericIndexedGetter"}
        || $dataNode->extendedAttributes->{"NamedGetter"}
        || $dataNode->extendedAttributes->{"CustomNamedGetter"}) {
        push(@getterSetterContent, "VALUE ${className}::square_brackets(VALUE self, VALUE key)\n");
        push(@getterSetterContent, "{\n");

        if ($dataNode->extendedAttributes->{"IndexedGetter"}
            || $dataNode->extendedAttributes->{"NumericIndexedGetter"}) {
            push(@getterSetterContent, "    if (IS_RB_NUM(key))\n");
            push(@getterSetterContent, "        return ${className}::indexed_getter(self, key);\n");
        }

        if ($dataNode->extendedAttributes->{"NamedGetter"} || $dataNode->extendedAttributes->{"CustomNamedGetter"}) {
            push(@getterSetterContent, "    return ${className}::named_getter(self, key);\n");
        } else {
            push(@getterSetterContent, "    return Qnil;\n");
        }

        push(@getterSetterContent, "}\n\n");
    }

    # []=
    if ($dataNode->extendedAttributes->{"CustomIndexedSetter"}
        || $dataNode->extendedAttributes->{"CustomNamedSetter"}) {
        push(@getterSetterContent, "VALUE ${className}::square_brackets_equals(VALUE self, VALUE key, VALUE value)\n");
        push(@getterSetterContent, "{\n");

        if ($dataNode->extendedAttributes->{"CustomIndexedSetter"}) {
            push(@getterSetterContent, "    if (IS_RB_NUM(key))\n");
            push(@getterSetterContent, "        return ${className}::indexed_setter(self, key, value);\n");
        }

        if ($dataNode->extendedAttributes->{"CustomNamedSetter"}) {
            push(@getterSetterContent, "    return ${className}::named_setter(self, key, value);\n");
        } else {
            push(@getterSetterContent, "    return Qnil;\n");
        }

        push(@getterSetterContent, "}\n\n");
    }

    # method_missing
    if ($dataNode->extendedAttributes->{"NamedGetter"} 
        || $dataNode->extendedAttributes->{"CustomNamedGetter"} 
        || $dataNode->extendedAttributes->{"CustomNamedSetter"}) {
        push(@getterSetterContent, "VALUE ${className}::method_missing(int argc, VALUE* argv, VALUE self)\n");
        push(@getterSetterContent, "{\n");
        push(@getterSetterContent, "    VALUE methodName, rest;\n");
        push(@getterSetterContent, "    rb_scan_args(argc, argv, \"1*\", &methodName, &rest);\n");

        if ($dataNode->extendedAttributes->{"CustomNamedSetter"}) {
            push(@getterSetterContent, "    String nameString = rbToString(methodName);\n");
            push(@getterSetterContent, "    if (nameString[nameString.length() - 1] == '=') {\n");
            push(@getterSetterContent, "        String propertyName = nameString.substring(0, nameString.length() - 1);\n");
            push(@getterSetterContent, "        VALUE rbPropertyName = rb_str_new2(propertyName.utf8().data());\n");
            push(@getterSetterContent, "        VALUE rbNewValue = rb_ary_shift(rest);\n");
            push(@getterSetterContent, "        return ${className}::named_setter(self, rbPropertyName, rbNewValue);\n");
            push(@getterSetterContent, "    }\n\n");
        }

        if ($dataNode->extendedAttributes->{"NamedGetter"} || $dataNode->extendedAttributes->{"CustomNamedGetter"}) {
            push(@getterSetterContent, "    return ${className}::named_getter(self, methodName);\n");
        } else {
            push(@getterSetterContent, "    return rb_call_super(argc, argv);\n");
        }
        push(@getterSetterContent, "}\n\n");
    }

    return @getterSetterContent;
}

sub GenerateOverloadedFunction
{
    my $function = shift;
    my $staticFunctionName = GetStaticFunctionName($function->signature->name);

    my $foundNonCustom = 0;
    foreach my $overload (@{$function->{overloads}}) {
        $foundNonCustom = 1 if !NeedsCustomImplementation($overload);
    }
    return () if !$foundNonCustom;

    my @functionContent = ();
    my $maxArgCount = 0;
    foreach my $overload (@{$function->{overloads}}) {
        my $paramCount = @{$overload->parameters};
        $maxArgCount = $paramCount if $paramCount > $maxArgCount;
        my $overloadName = $staticFunctionName . $overload->{overloadIndex};

        if ($paramCount == 0) {
            push(@functionContent, "    if (NIL_P(arg0))\n");
            push(@functionContent, "        return $overloadName(self);\n");
        } else {
            my @paramChecks = ();
            my $functionCall = "$overloadName(self";
            my $i = 0;
            foreach my $parameter (@{$overload->parameters}) {
                my $typeChecker = GetTypeChecker("arg$i", $parameter);
                if ($parameter->extendedAttributes->{"Optional"}) {
                    $typeChecker = "(NIL_P(arg$i) || $typeChecker)";
                }
                push(@paramChecks, $typeChecker);
                $functionCall .= ", arg$i";
                $i++;
            }
            $functionCall .= ")";

            my $conditional = "    if (";
            my $optionalCount = CountOptionalArguments($overload);
            if ($optionalCount) {
                $conditional .= "(argc <= $i && argc >= " . ($i - $optionalCount) . ") && ";
            } else {
                $conditional .= "argc == $i && ";
            }
            $conditional .= join(" && ", @paramChecks) . ")\n";
            push(@functionContent, $conditional);

            if ($optionalCount) {
                $functionCall = "$overloadName(argc, argv, self)";
            }
            push(@functionContent, "        return $functionCall;\n\n");
        }
    }
    push(@functionContent, "    rb_raise(rb_eArgError, \"Invalid arguments to ${staticFunctionName}\");\n");
    push(@functionContent, "    return Qnil;\n");

    my $argDeclaration = "VALUE arg0";
    my $scanArgs = "rb_scan_args(argc, argv, \"0${maxArgCount}\", &arg0";
    for (1..($maxArgCount - 1)) {
        $argDeclaration .= ", arg$_";
        $scanArgs .= ", &arg$_";
    }

    my @content = ();
    push(@content, "VALUE ${className}::$staticFunctionName(int argc, VALUE* argv, VALUE self)\n");
    push(@content, "{\n");
    push(@content, "    $argDeclaration;\n");
    push(@content, "    $scanArgs);\n\n");
    push(@content, @functionContent);
    push(@content, "}\n\n");

    return @content;
}

sub GenerateSecurityChecks
{
    my $function = shift;
    my $raisesExceptions = shift;

    my @output = ();

    if ($interface->extendedAttributes->{"CheckSecurity"} and !$function->signature->extendedAttributes->{"DoNotCheckSecurity"}) {
        $implIncludes{"BindingSecurity.h"} = 1;
        $implIncludes{"RBScriptState.h"} = 1;
        push(@output, "    if (!BindingSecurity::shouldAllowAccessToDOMWindow(RBScriptState::current(), $implSelf))\n");
        push(@output, "        return Qnil;\n\n");
    }

    if ($function->signature->extendedAttributes->{"CheckSecurityForNode"}) {
        $implIncludes{"BindingSecurity.h"} = 1;
        $implIncludes{"RBScriptState.h"} = 1;
        my $callSignature = $function->signature->name . ($raisesExceptions ? "(ec)" : "()");
        push(@output, "    if (!BindingSecurity::shouldAllowAccessToNode(RBScriptState::current(), $implSelf->$callSignature))\n");
        push(@output, "        return Qnil;\n\n");
    }

    return @output;
}

sub WrapWithSVGConverter
{
    my $signature = shift;
    my $value = shift;
    my $useUpdateMethod = shift;
    my $type = $signature->type;

    my $tearOffType = $codeGenerator->GetSVGTypeNeedingTearOff($type);
    if ($codeGenerator->IsSVGAnimatedType($interfaceName) or $interfaceName eq "SVGViewSpec") {
        return "static_cast<$tearOffType*>($value)";
    } elsif ($codeGenerator->IsSVGTypeNeedingTearOff($type) and not $interfaceName =~ /List$/) {
        if ($codeGenerator->IsSVGTypeWithWritablePropertiesNeedingTearOff($type) and $useUpdateMethod and !$signature->extendedAttributes->{"Immutable"}) {
            my $getter = $signature->name;
            my $updateMethod = "&${interfaceName}::update" . $codeGenerator->WK_ucfirst($getter);

            my $selfIsTearOffType = $codeGenerator->IsSVGTypeNeedingTearOff($interfaceName);
            if ($selfIsTearOffType) {
                $implIncludes{"SVGStaticPropertyWithParentTearOff.h"} = 1;
                $tearOffType =~ s/SVGPropertyTearOff</SVGStaticPropertyWithParentTearOff<$interfaceName, /;

                if ($value =~ /matrix/ and $interfaceName eq "SVGTransform") {
                    # SVGTransform offers a matrix() method for internal usage that returns an AffineTransform
                    # and a svgMatrix() method returning a SVGMatrix, used for the bindings.
                    $value =~ s/matrix/svgMatrix/;
                }

                $value = "${tearOffType}::create($svgSelf, $value, $updateMethod)";
            } else {
                $implIncludes{"SVGStaticPropertyTearOff.h"} = 1;
                $tearOffType =~ s/SVGPropertyTearOff</SVGStaticPropertyTearOff<$interfaceName, /;
                $value = "${tearOffType}::create($implSelf, $value, $updateMethod)";
            }
        } elsif ($tearOffType =~ /SVGStaticListPropertyTearOff/) {
            return "${tearOffType}::create($implSelf, $value)";
        } elsif (not $tearOffType =~ /SVG(Point|PathSeg)List/) {
            return "${tearOffType}::create($value)";
        }
    }

    return $value;     
}

sub SuppressToRBImplementation
{
    my $dataNode = shift;
    return 0 if $dataNode->extendedAttributes->{"TypedArray"};
    return 1 if $dataNode->name eq "Element";
    return 1 if $dataNode->extendedAttributes->{"CustomToJSObject"};
    return 0;
}

sub GenerateOperatorEqualsImplementation
{
    my $selfConverter = RBToNativeConverter("self", $interfaceName);
    my $otherConverter = RBToNativeConverter("other", $interfaceName);

    my $nativeType = GetNativeType($interfaceName);
    if ($codeGenerator->IsSVGTypeNeedingTearOff($interfaceName)) {
        if (!($interfaceName =~ /List$/)) {
            $nativeType = $codeGenerator->GetSVGWrappedTypeNeedingTearOff($interfaceName);
            $nativeType .= "*";
            $selfConverter = "&$selfConverter";
            $otherConverter = "&$otherConverter";
        }
    }

    my $content = << "EOF";
VALUE ${className}::operator_equals(VALUE self, VALUE other)
{
    if (self == other)
        return Qtrue;

    if (CLASS_OF(self) != CLASS_OF(other))
        return Qfalse;

    $nativeType selfImpl = $selfConverter;
    $nativeType otherImpl = $otherConverter; 
    bool equals = (selfImpl == otherImpl);
    return toRB(equals);
}

EOF

    return $content;
}

sub GenerateImplementation
{
    my $object = shift;
    my $dataNode = shift;

    # - Add default header template.
    @implContentHeader = split("\r", $implementationLicenseTemplate);

    # - INCLUDES -
    push(@implContentHeader, "\n#include \"config.h\"\n");
    my $conditionalString = $codeGenerator->GenerateConditionalString($dataNode);    
    push(@implContentHeader, "\n#if ${conditionalString}\n\n") if $conditionalString;
    push(@implContentHeader, "#include \"$className.h\"\n\n");

    $implIncludes{"RBExceptionHandler.h"} = 1;
    $implIncludes{"RBConverters.h"} = 1;
    $implIncludes{"<Ruby/ruby.h>"} = 1;
    AddIncludesForType($interfaceName);
    @implContent = ();

    push(@implContent, "namespace WebCore {\n\n");
    
    # Declare the static class variable
    my $rbClassVariable = GetRubyClassVariableName($interfaceName);
    push(@implContent, "VALUE ${className}::${rbClassVariable};\n\n");

    # - CONSTRUCTORS -
    # FIXME: Handle NamedConstructor
    $constructorTemplate = $dataNode->extendedAttributes->{"ConstructorTemplate"};
    if ($constructorTemplate and $constructorTemplate eq "Event") {
        push(@implContent, GenerateEventConstructorImplementation($dataNode));
    } elsif ($constructorTemplate and $constructorTemplate eq "TypedArray") {
        push(@implContent, GenerateTypedArrayConstructorImplementation($dataNode));
    } elsif (@{$dataNode->constructors} and !$dataNode->extendedAttributes->{"NamedConstructor"}) {
        push(@implContent, GenerateConstructorImplementation($dataNode));
    } elsif ($dataNode->extendedAttributes->{"CustomConstructor"}) {
        push(@implCustomContent, GenerateConstructorImplementation($dataNode));
    } elsif (!$dataNode->extendedAttributes->{"NamedConstructor"}) {
        push(@implContent, GenerateConstructorImplementation($dataNode));
    }

    # - ATTRIBUTES -
    # Connect each getter and setter to the WebCore implementation.
    if (@{$dataNode->attributes} > 0) {
        foreach my $attribute (@{$dataNode->attributes}) {
            next if SkipAttribute($attribute);

            my $idlType = $attribute->signature->type;
            my $attributeName = $attribute->signature->name;
            my $attributeIsReadonly = ($attribute->type =~ /^readonly/);
            my $attributeConditionalString = $codeGenerator->GenerateConditionalString($attribute->signature);
            my $isNullable = $attribute->signature->isNullable;

            #            #
            # - GETTER - #
            #            #
            my @getterContent = ();
            my $getterName = GetRubyFunctionName($attributeName) . "_getter";
            push(@getterContent, "#if ${attributeConditionalString}\n") if $attributeConditionalString;
            push(@getterContent, "VALUE ${className}::$getterName(VALUE" . ($attribute->isStatic ? "" : " self") . ")\n");
            push(@getterContent, "{\n");
            push(@getterContent, "    $implSelfDeclaration;\n") if !$attribute->isStatic;
            push(@getterContent, GenerateSecurityChecks($attribute)) unless $attribute->signature->extendedAttributes->{"DoNotCheckSecurityOnGetter"};
            my @callWithArgs = GenerateCallWith($attribute->signature->extendedAttributes->{"CallWith"}, \@getterContent);
            
            $isCustomGetter = ($attribute->signature->extendedAttributes->{"CustomGetter"} or $attribute->signature->extendedAttributes->{"Custom"});
            if ($isCustomGetter) {
                push(@getterContent, "    $notImplementedFixme\n");
                push(@getterContent, "    $notImplementedRaise\n");
                push(@getterContent, "    return Qnil;\n");
            } else {

                if ($attribute->signature->type eq "EventListener") {
                    my $setterName = GetRubyFunctionName($attributeName . "Setter");
                    push(@getterContent, "    if (rb_block_given_p())\n");
                    push(@getterContent, "        return ${className}::${setterName}(self, rb_block_proc());\n");
                }

                my $hasGetterException = @{$attribute->getterExceptions};
                my ($functionName, @arguments) = $codeGenerator->GetterExpression(\%implIncludes, $interfaceName, $attribute);
                push(@arguments, "ec") if $hasGetterException;
                if ($attribute->signature->extendedAttributes->{"ImplementedBy"}) {
                    my $implementedBy = $attribute->signature->extendedAttributes->{"ImplementedBy"};
                    $implIncludes{"$implementedBy.h"} = 1;
                    unshift(@arguments, $implSelf);
                    $functionName = "${implementedBy}::${functionName}";
                } elsif ($attribute->isStatic) {
                    $functionName = "${interfaceName}::${functionName}";
                } else {
                    $functionName = "$implSelf->$functionName";
                }

                unshift(@arguments, @callWithArgs);
                push(@arguments, "isNull") if $isNullable;
                my $functionCall = "$functionName(" . join(", ", @arguments) . ")";

                if ($codeGenerator->IsSVGTypeNeedingTearOff($interfaceName) and $codeGenerator->GetSVGWrappedTypeNeedingTearOff($interfaceName) eq "float") {
                    $functionCall = $implSelf;
                }

                if ($codeGenerator->IsSVGTypeNeedingTearOff($idlType)) {
                    $functionCall = WrapWithSVGConverter($attribute->signature, $functionCall, 1);
                } elsif ($codeGenerator->IsSVGAnimatedType($idlType)) {
                    $functionCall .= ".get()";
                } elsif ($attribute->signature->extendedAttributes->{"TreatReturnedNullStringAs"}) {
                    $functionCall .= ", false";
                } elsif ($attribute->signature->type eq "Date") {
                    $functionCall .= ", Date";
                }

                push(@getterContent, "    $exceptionInit\n") if $hasGetterException;
                push(@getterContent, "    bool isNull = false;\n") if $isNullable;
                push(@getterContent, "    VALUE result = toRB($functionCall);\n");
                if ($isNullable) {
                    push(@getterContent, "    if (isNull)\n");
                    push(@getterContent, "        return Qnil;\n");
                }
                push(@getterContent, "    $exceptionRaiseOnError\n") if $hasGetterException;
                push(@getterContent, "    return result;\n");
            }
            push(@getterContent, "}\n");
            push(@getterContent, "#endif\n") if $attributeConditionalString;
            push(@getterContent, "\n");
            
            if ($isCustomGetter) {
                push(@implCustomContent, @getterContent);
            } else {
                AddIncludesForType($attribute->signature->type);
                push(@implContent, @getterContent);
            }
            
            #            #
            # - SETTER - #
            #            #
            if (!$attributeIsReadonly) {
                my @setterContent = ();
                my $setterName = GetRubyFunctionName($attributeName . "Setter");
                my $argName = "new" . ucfirst($attributeName);
                my $arg = RBToNative($argName, $attribute->signature, 1);
            
                push(@setterContent, "#if ${attributeConditionalString}\n") if $attributeConditionalString;
                push(@setterContent, "VALUE ${className}::$setterName(VALUE self, VALUE $argName)\n");
                push(@setterContent, "{\n");
                push(@setterContent, "    $implSelfDeclaration;\n");
                push(@setterContent, GenerateSecurityChecks($attribute)) unless $attribute->signature->extendedAttributes->{"DoNotCheckSecurityOnSetter"};
                
                $isCustomSetter = ($attribute->signature->extendedAttributes->{"Replaceable"} 
                                or $attribute->signature->extendedAttributes->{"CustomSetter"}
                                or $attribute->signature->extendedAttributes->{"Custom"});
            
                if ($isCustomSetter) {
                    push(@setterContent, "    $notImplementedFixme\n");
                    push(@setterContent, "    $notImplementedRaise\n");
                } else {
                    my $hasSetterException = @{$attribute->setterExceptions};
                    my ($functionName, @arguments) = $codeGenerator->SetterExpression(\%implIncludes, $interfaceName, $attribute);
                    push(@arguments, $arg);
                    push(@arguments, "ec") if $hasSetterException;
                    if ($attribute->signature->extendedAttributes->{"ImplementedBy"}) {
                        my $implementedBy = $attribute->signature->extendedAttributes->{"ImplementedBy"};
                        $implIncludes{"${implementedBy}.h"} = 1;
                        unshift(@arguments, $implSelf);
                        $functionName = "${implementedBy}::${functionName}";
                    } elsif ($attribute->isStatic) {
                        $functionName = "${interfaceName}::${functionName}";
                    } else {
                        $functionName = "$implSelf->${functionName}";
                    }
                    push(@setterContent, "    $exceptionInit\n") if $hasSetterException;
                    if ($attribute->signature->type eq "EventListener") {
                        push(@setterContent, "    ${functionName}(RBEventListener::create($argName, true));\n");
                    } elsif ($codeGenerator->IsSVGTypeNeedingTearOff($interfaceName) and $codeGenerator->GetSVGWrappedTypeNeedingTearOff($interfaceName) eq "float") {
                        push(@setterContent, "    *$implSelf = " . $arguments[0] . ";\n");
                    } else {
                        push(@setterContent, "    ${functionName}(" . join(", ", @arguments) . ");\n");
                    }
                    push(@setterContent, "    $exceptionRaiseOnError\n") if $hasSetterException;

                    if ($codeGenerator->IsSVGTypeNeedingTearOff($interfaceName)) {
                        if ($hasSetterException) {
                            push(@setterContent, "    if (!ec)\n");
                            push(@setterContent, "        $svgSelf->commitChange();\n");
                        } else {
                            push(@setterContent, "    $svgSelf->commitChange();\n");
                        }
                    }
                }

                push(@setterContent, "    return ${argName};\n");
                push(@setterContent, "}\n");
                push(@setterContent, "#endif\n") if $attributeConditionalString;
                push(@setterContent, "\n");
            
                if ($isCustomSetter) {
                    push(@implCustomContent, @setterContent);
                } else {
                    AddIncludesForType($attribute->signature->type);
                    push(@implContent, @setterContent);
                }
            }
        }
    }

    # - FUNCTIONS -
    if (@{$dataNode->functions} > 0) {
        foreach my $function (@{$dataNode->functions}) {
            next if SkipFunction($function);

            my @functionContent = GenerateFunctionImplementation($function);
            if (NeedsCustomImplementation($function)) {
                push(@implCustomContent, @functionContent);
            } else {
                push(@implContent, @functionContent);
            }

            my $isOverloaded = $function->{overloads} && @{$function->{overloads}} > 1;
            if ($isOverloaded and $function->{overloadIndex} == @{$function->{overloads}}) {
                my @overloadedContent = GenerateOverloadedFunction($function);
                push(@implContent, @overloadedContent);
            }
        }
    }
    
    # - INDEXED/NAMED GETTERS/SETTERS -
    push(@implContent, GenerateGetterSetterImplementation($dataNode));

    # - OPERATOR EQUALS -
    push(@implContent, GenerateOperatorEqualsImplementation());

    # Generate the function that converts to Ruby. 
    # FIXME: Do TypedArrays need a custom toRB like JS's toArrayBufferView?
    if (!SuppressToRBImplementation($dataNode)) {
        my $converterType = $interfaceName;
        if ($codeGenerator->IsSVGTypeNeedingTearOff($interfaceName)) {
            $converterType = $codeGenerator->GetSVGTypeNeedingTearOff($interfaceName);
        }
        push(@implContent, "VALUE toRB($converterType* impl)\n");
        push(@implContent, "{\n");
        push(@implContent, "    return toRB(${className}::rubyClass(), impl);\n");
        push(@implContent, "}\n");
    }

    push(@implContent, "\n} // namespace WebCore\n");
    
    # END implementation

    # - End the ifdef conditional if necessary
    push(@implContent, "\n#endif // ${conditionalString}\n") if $conditionalString;
    push(@implCustomContent, "#endif // ${conditionalString}\n") if ($conditionalString and @implCustomContent);
}

# Internal helper
sub WriteData
{
    my $object = shift;
    my $dataNode = shift;
    my $outputDir = shift;

    # We may not want to write anything at all.
    return if $object->SkipInterface($dataNode);

    my $name = $dataNode->name;
    my $headerFileName = "$outputDir/$prefix$name.h";
    my $implFileName = "$outputDir/$prefix$name.cpp";
    my $implCustomFileName = "$outputDir/${prefix}${name}Custom.cpp";

    # Update the .h file.
    my $contents = join "", @headerContentHeader;
    $contents .= "\n";
    $contents .= join "", @headerContent;
    $codeGenerator->UpdateFile($headerFileName, $contents);
    @headerContentHeader = ();
    @headerContent = ();

    # Update the .cpp file.
    $contents = join "", @implContentHeader;

    my @includes = ();
    foreach my $include (keys %implIncludes) {
        $include = "\"$include\"" unless $include =~ /^["<]/; # "
        push(@includes, $include);
    }
    foreach my $include (sort @includes) {
        next if $include eq "$name.h";
        $contents .= "#include $include\n";
    }

    $contents .= "\n";
    $contents .= join "", @implContent;
    $codeGenerator->UpdateFile($implFileName, $contents);
    
    # Update the custom implementation file if we want to.
    if (GenerateCustomImplementation and @implCustomContent) {
        pop(@implContentHeader);
        $contents = join "", @implContentHeader;
        $contents .= "\n";
        $contents .= join "", @implCustomContent;
        $codeGenerator->UpdateFile($implCustomFileName, $contents);
    }

    @implContentHeader = ();
    @implContent = ();
    @implCustomContent = ();
    %implIncludes = ();
}

1;
