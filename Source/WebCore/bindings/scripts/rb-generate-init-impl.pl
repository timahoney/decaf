#
# Copyright (C) 2012 Tim Mahoney <tim.mahoney@me.com>
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Library General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Library General Public License for more details.
# 
# You should have received a copy of the GNU Library General Public License
# aint with this library; see the file COPYING.LIB.  If not, write to
# the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
# Boston, MA 02110-1301, USA.
#

# We need to add the Init_ClassName function to the initialization file.
# Create the RBInitialization.cpp file with the appropriate header.
# Find all the files with the prefix "RB" and include them.
# Then, add the Init_ClassName method for all of them.

# For now, just use the current directory.
my $outputDir = ".";
my $inputDir = ".";

# Delete any previous initialization file.
my $initFileName = $outputDir . "\/RBInitialization.cpp";
if ((-e $initFileName)) {
    unlink($initFileName);
}

# Find all the RB interface files.
opendir(DIR, $inputDir);
my @rbFiles = grep(/^(RB).*\.h/, readdir(DIR));
closedir(DIR);

# Filter out the files that we don't really use.
my @files = ();
foreach $file (@rbFiles) {
    my $className = $file;
    $className =~ s/\.h//;

    open(FILE, "${inputDir}\/${file}");
    push(@files, $file) if ((grep{/class ${className}/} <FILE>) and !($file =~ "Callback"));
    close FILE;
}

my $implementationLicenseTemplate = << "EOF";
/*
 * This file is part of the WebKit open source project.
 * This file has been generated by generate-bindings.pl. DO NOT MODIFY!
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public License
 * along with this library; see the file COPYING.LIB.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301, USA.
 */
EOF

open FH, "> $initFileName" or die "Couldn't open $initFileName: $!\n";
my @initContentHeader = split("\r", $implementationLicenseTemplate);
push(@initContentHeader, "\n");
push(@initContentHeader, "#include \"config.h\"\n");
push(@initContentHeader, "#include \"RBInitialization.h\"\n\n");

# Add the include statements for each file.
foreach $file (@files) {
    push(@initContentHeader, "#include \"$file\"\n");
}

push(@initContentHeader, "\n");
push(@initContentHeader, "namespace WebCore {\n\n");

# Add the initialization function with the Init_ClassName function from each interface.
push(@initContentHeader, "void RBInitialization::initializeRubyClasses()\n{\n");
foreach $file (@files) {
    my $interfaceName = $file;
    $interfaceName =~ s/\.h//;
    $interfaceName =~ s/^RB//;

    # Check for an enable flag.
    my $enableFlag;
    open my $contents, $file or die "Could not open $file: $!";
    while(my $line = <$contents>) {
        $enableFlag = $line if $line =~ "#if ";
        last if $line =~ "class RB${interfaceName}";
    }

    push(@initContentHeader, "${enableFlag}") if $enableFlag;
    push(@initContentHeader, "    RB${interfaceName}::Init_${interfaceName}();\n");
    push(@initContentHeader, "#endif\n") if $enableFlag;
}
push(@initContentHeader, "}\n\n");
push(@initContentHeader, "} // namespace WebCore\n");

# Write the file.
my $initContents = join "", @initContentHeader;
print FH $initContents;
close FH;